const codeContainer = require(`${__dirname}/code-container/container`);
const fs = require("fs-extra");
const path = require("path");
const { fork } = require('child_process');
const mongoClient = require('mongodb').MongoClient;
const ObjectId = require("mongodb").ObjectID;
const ipc = require('node-ipc');

const serviceName = process.env.SERVICE_NAME;

// ipc settings
// Reference:
// http://riaevangelist.github.io/node-ipc/#ipc-config
ipc.config.appspace = "gateway.";
ipc.config.socketRoot = path.normalize(`${__dirname}/../socket/`);
ipc.config.id = serviceName;
ipc.config.retry = 1500;
ipc.config.silent = true;

// Connect to platform manager
ipc.connectTo('platform', () => {
    ipc.of.platform.on('connect', () => {
        console.log(`${serviceName} connected to platform`);
        let message = {
            "meta": {
                "sender": serviceName,
            },
            "payload": `${serviceName} sent back the socket.`
        };
        ipc.of.platform.emit("register-socket", message);
    });
    ipc.of.platform.on('disconnect', () => {
        console.log(`${serviceName} disconnected from platform`);
    });
});

// db settings
const mongoUrl = 'mongodb://localhost:27017';
const appsDb = 'apps';
const appsInfoCollection = 'info';

// Initialize database connection once
var db;
mongoClient.connect(mongoUrl, { useNewUrlParser: true }, function(err, client) {
    if(err) throw err;
    db = client.db(appsDb);
});

// Create logs directory for apps if not present
fs.ensureDirSync(`${__dirname}/logs`);
/**
 * This function saves the app info to the database
 * @param {string} appName application name
 * @param {string} topic mqtt topic
 * @param {string} pid application pid
 * @returns {int}
 */
function saveAppInfoToDB(appName, topic, pid) {
    try {
        let result = db.collection(appsInfoCollection)
                        .update({ "_id": new ObjectId(topic) }, {
                            "pid": pid,
                            "name": appName
                        });
        if("writeConcernError" in result)
            throw result["writeConcernError"];
        console.log(`Deployed successfully!`);
        console.log(`  time:   ${new Date().toISOString()}`);
        console.log(`  app:    ${appName}`);
        console.log(`  topic:  ${topic}`);
        console.log(`  pid:    ${pid}`);
    } catch (err) {
        console.error(`deploy ${appName} failed.`);
        console.error(err);
        return 1;
    };
    return 0;
}

// apps stores process, topic, pid, and path
const apps = {};

/**
 * This function generates the topic for new coming app.
 * the topic is the id generated by mongodb
 * @param {string} appName
 * @returns {string}
 */
async function getTopic(appName) {
    let appId = undefined;
    try {
        let result = await db.collection(appsInfoCollection)
                        .insertOne( {
                            "appName": appName,
                        });
        appId = result["insertedId"].valueOf();
    } catch (err) {
        console.error(err);
    };
    return appId;
}

function notifySSM(app) {
    ipc.of.platform.emit("forward", {
        "meta": {
            "sender": serviceName,
            "recipient": "sensor-stream-manager",
            "event": "app-deployment"
        },
        "payload": {
            "app": app,
            "metadataPath": path.dirname(app["path"]) + "/metadata.json"
        }
    });
}

// When app-manager get appPath and metadataPath from platform-manager,
// app-manager will fork a process for executing new app.
ipc.of.platform.on('app-deployment', message => {
    let appData = message.data;
    if(appData.appPath && appData.metadataPath) {
        let appPath, appName;
        codeContainer.setApp(appData.appPath, appData.metadataPath)
            .then((newAppPath) => {
                appPath = newAppPath;
                // appPath = /on-the-edge/app-manager/code-container/executables/1583622378159/app.js
                appName = path.basename(newAppPath);
                // generate application's MQTT topic
                return getTopic(appName);
            })
            .then((appTopic) => {
                if(!appTopic)
                    throw new Error(`[Set App] ${appName} get topic failed.`);
                // Using fork() to create a child process for a new application
                // Using fork() not spawn() is because fork is a special instance of spawn for creating a Nodejs child process.
                // Reference:
                // https://stackoverflow.com/questions/17861362/node-js-child-process-difference-between-spawn-fork
                const newApp = fork(appPath, [], {
                    env: { TOPIC: appTopic },
                    stdio: [
                        0,
                        fs.openSync(`${__dirname}/logs/${appName}.out`, 'a'),
                        fs.openSync(`${__dirname}/logs/${appName}.out`, 'a'),
                        "ipc"
                    ]
                });
                // save application's name and pid in mongodb
                saveAppInfoToDB(appName, appTopic, newApp.pid);

                // Stores the process, topic, pid, and path in apps
                // application's topic is its id
                apps[appName] = {
                    "app": newApp, // instance of process
                    "topic": appTopic, // app's id (the same as mongodb _id)
                    "path": appPath
                };
                notifySSM(apps[appName]);
            })
            .catch(err => console.error(err));
    }
});